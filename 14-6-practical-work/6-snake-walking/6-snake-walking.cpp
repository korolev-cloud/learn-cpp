#include <iostream>
#define FIELD_SIZE 5

int main()
{
    int number = 0; // счетчик
    int digits[FIELD_SIZE][FIELD_SIZE]; //создаем пустой массив
    int multiplier = FIELD_SIZE - 1; //переменная для смены знака при переходе на следующую строку
    for (int i = 0; i < FIELD_SIZE; ++i) {
        for (int j = 0; j < FIELD_SIZE; ++j) {
            digits[i][std::abs(((multiplier - (FIELD_SIZE - 1)) / 2) + j)] = number;
            // заполняем массив-нечетные строки слева направо, четные наоборот
            number++; // увеличиваем счетчик
        }
        for (int j = 0; j < FIELD_SIZE; ++j) {
            std::cout << digits[i][j] << " ";
            if (digits[i][j] < 10) std::cout << " "; // добавляем пробел для красоты таблицы
        }
        multiplier *= -1; //меняем знак
        std::cout << std::endl;
    }
}

/*
 
Есть двумерный массив целых чисел размером 5 на 5 элементов. 
Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации. 
Элементы должны быть инициализированы не последовательно, а змейкой: 
в конце каждой строки мы должны не переходить к первому элементу следующей строки, 
а начать наоборот, с последнего элемента и так далее. В конечном отображении массива 
числа должны быть упорядочены по возрастанию, но змеевидно от строке к строке. 
Сама же последовательность чисел — это простое линейное возрастание от 0 до 24, 
для её учёта можно завести отдельную переменную.

Попытайтесь решить эту задачу используя минимальное количество временных переменных 
и без условных переходов if. Если вы найдёте формулу индексации, будет замечательно! 
Она может быть весьма витиеватой..

Советы и рекомендации
Результирующий массив должен выглядеть так:

0 1 2 3 4
9 8 7 6 5
10 11 12 13 14
19 18 17 16 15
20 21 22 23 24

Внешний и внутренний циклы идут от 0 до 5, тут ничего нового. 
Первый индекс (строка) тоже без сюрпризов: это значение счётчика внешнего цикла:

for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            digits[i][...] = number;
            number += 1;
        }
…
    }

Самое сложное тут — это номер столбца. Чтобы сначала двигаться слева направо, 
а на следующей строке наоборот, стоит завести переменную-множитель, 
которая на чётных строках будет равна 1. На нечётных строках меняет знак: multiplier *= −1;

Что оценивается
В решении не используются условные конструкции.

*/   