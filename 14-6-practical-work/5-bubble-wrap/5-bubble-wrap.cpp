#include <iostream>
#define FIELD_SIZE 12

void initShell(bool status, bool (&shell)[FIELD_SIZE][FIELD_SIZE]) {
    // передаем в функцию статус и указатель на массив
    for (int i = 0; i < FIELD_SIZE; i++) {
        for (int j = 0; j < FIELD_SIZE; j++) {
            shell[i][j] = status;
            // меняем значение ячейки 
        }
    }
}

void showShell(bool(&shell)[FIELD_SIZE][FIELD_SIZE]) {
    // вывод содержимого массива
    for (int i = 0; i < FIELD_SIZE; i++) {
        for (int j = 0; j < FIELD_SIZE; j++) {
            if (shell[i][j] == true) std::cout << "o";
            else std::cout << "x";
        }
        std::cout << std::endl;
    }
}

int popShell(bool(&shell)[FIELD_SIZE][FIELD_SIZE], int x1, int y1, int x2, int y2) {
    int counter = 0; // счетчик лопнутых пузырьков
    for (int i = x1-1; i < x2; i++) {
        for (int j = y1-1; j < y2; j++) {
            shell[i][j] = false;
            // меняем состояние ячейки
            showShell(shell);
            // вывод пленки
            std::cout << "Pop!" << std::endl;
            counter++;
        }
    }
    return counter; // возвращаем количество лопнутых пузырьков
}

int main()
{
    bool shell[FIELD_SIZE][FIELD_SIZE];
    initShell(true, shell);
    int burstСounter = FIELD_SIZE*FIELD_SIZE;
    int x1, x2, y1, y2;
    while (burstСounter)
    {
        std::cout << "Entered coordinate to burst (format x1 y1 x2 y2): ";
        std::cin >> x1 >> y1 >> x2 >> y2;
        if (x1 > 0 && x1 <= FIELD_SIZE && x2 > 0 && x2 <= FIELD_SIZE
            && y1 > 0 && y1 <= FIELD_SIZE && y2 > 0 && y2 <= FIELD_SIZE) {
            // если введенные данные содержат координаты внутри поля
            int popBubbles = popShell(shell, x1, y1, x2, y2);
            burstСounter -= popBubbles;
        }
        else
        {
            std::cout << std::endl << "Mistake! The entered range is out of the field!";
            std::cout << std::endl;
        }
    }
}

/*

После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. 
Всего в пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый, либо нет, 
то есть true или false (тип массива — bool). Для начала требуется реализовать отдельную функцию 
инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true.

Программа заключается в последовательном лопании целых регионов пузырьков. 
Перед каждым таким лопанием надо показывать пользователю полностью всю плёнку: 
o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию. 
Итак, как выглядит само лопание. Пользователь вводит две координаты: начала региона и конца региона. 
Процедура лопания пузырей должна быть реализована с помощью отдельной функции, 
все аргументы должны проверяться на валидность, что они в в рамках диапазона возможных значений, 
иначе должна быть выведена ошибка. После лопания каждого пузыря, который не был ещё лопнут до того, 
в консоль должно выводиться сообщение “Pop!”.

Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена,
программа заканчивает выполнение. Вы можете подсчитать окончание в самой функции по 
отображению пузырьков плёнки, так как функция выполняется после каждого лопания.

Советы и рекомендации
Обратите внимание, что лопание пузырей делается с помощью региона, а не одной точки.
Регион задаётся двумя координатами, это координаты углов прямоугольника.
При лопании региона достаточно запустить цикл только по этим элементам. 
Не нужно проходить каждый раз по всей матрице.
Всю область плёнки удобно представить в виде двумерного массива типа bool.
Инициализировать вручную такой массив сложно, лучше воспользоваться вложенными циклами.

*/