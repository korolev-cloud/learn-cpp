#include <iostream>

void bubblesort(float* start, float* end) 
{
	int sz = end - start;
	// определение размера массива
	if (sz <= 1) return;
	// выход из функции по достижении конца массива
	bool b = true;
	while (b) {
		b = false;
		for (float* i = start; i + 1 < end; i++) 
		// цикл по элементам массива
		{
			if (*i < *(i + 1)) 
			// если элемент массива с индексом i меньше значения справа
			{
				std::swap(*i, *(i + 1));
				// поменять элементы массива местами
				b = true;
			}
		}
		end--;
	}
}

int main()
{
    const int SIZE = 15;
	float numberList[SIZE];
    std::cout << "Input: ";
    for (int i = 0; i < SIZE; i++)
    {
        std::cin >> numberList[i];
    }
	
	float* begin{ std::begin(numberList) };
	// указатель на начало массива
	float* end{ std::end(numberList) };
	// указатель на элемент за последним элементом массива

	bubblesort(begin, end);
	// выполнение сортировки массива

    std::cout << "Output: ";
    for (int i = 0; i < 15; i++)
    {
        std::cout << numberList[i] << " ";
    }
    std::cout << std::endl;
}

/*

Что нужно сделать
Пользователь вводит в консоль 15 дробных чисел. Необходимо прочитать их 
и вывести в консоль в порядке от большего к меньшему. По возможности 
используйте минимум дополнительной памяти и проходов по массиву.

Пример
Ввод: 1.2 2.3 1.11 3.4 5.5 5.4 5.3 5.1 1.5 1.25 5.41 5.31 5.11 1.51 1.251
Вывод: 5.5 5.41 5.4 5.31 5.3 5.11 5.1 3.4 2.3 1.51 1.5 1.251 1.25 1.2 1.11

Рекомендации по выполнению
Воспользуйтесь дополнительными материалами.

Что оценивается
Используется массив чисел с плавающей точкой для хранения данных.
В коде не используются библиотеки, кроме <iostream>.
Программа корректно использует обращения по индексам и выдаёт правильный ответ.
Асимптотическая сложность алгоритма не более O(n^2).
Числа выводятся от большего к меньшему.

*/
