#include <iostream>

bool substr(const char* pA, const char* pB){
    for (int i = 0; pA[i] != '\0'; i++){
        bool found = true;
        for (int j = 0; pB[j] != '\0'; j++){
            if (pA[i] == '\0' || pA[i + j] != pB[j]) {
                // если дошли до конца подстроки
                // или символ строки не равен символу подстроки
                found = false;
                break;
            }
        }
        if (found) return true;
    }
    return false;
}

int main() {
    const char* a = "Hello world";
    const char* b = "wor";
    const char* c = "banana";
    std::cout << (substr(a,b) ? "true" : "false") << " "
        << (substr(a,c) ? "true" : "false") << std::endl;
    return 0;
}


/*
 
 Напишите функцию, принимающую два указателя на char*, по которым размещены две строки.

 Функция должна возвращать true, если вторая строка является подстрокой первой.

 Пример
 const char* a = "Hello world";
 const char* b = "wor";
 const char* c = "banana";
 std::cout << substr(a,b) << " " << substr(a,c);
 // true false
 Const-квалификатор
 Const является квалификатором типа, применяемым к переменным,
 значения которых нельзя изменять.

 Например, если в коде написать:
 const int a = 2;
 то впоследствии значение переменной невозможно будет изменить, а запись вида
 a = 3;
 приведёт к ошибке компилятора.
 
 Чек-лист для проверки задачи
 Функция принимает корректные типы данных, тип возвращаемого значения — bool.
 Для работы со строками разрабатываемая функция может использовать только стандартную
 функцию strlen, входящую в библиотеку <cstring>. Допускается не использовать стандартные
 функции, а размер строки определять по нуль-символу ‘\0’.
 Функция корректно определяет, является ли вторая строка подстрокой первой.
 
 */
